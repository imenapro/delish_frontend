import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { format } from 'date-fns';
import { toast } from 'sonner';

interface ShiftReportData {
  session: {
    id: string;
    opened_at: string;
    closed_at?: string | null;
    opening_cash: number;
    total_sales: number;
    total_orders: number;
    shop?: {
      name: string;
      address?: string;
    };
    user?: {
      name: string;
    };
  };
  shiftOrders: any[];
  closingCash: number;
  expectedCash: number;
  description?: string;
}

export const generateShiftReportPDF = ({
  session,
  shiftOrders,
  closingCash,
  expectedCash,
  description
}: ShiftReportData) => {
  try {
    const doc = new jsPDF();
    const shopName = session.shop?.name || 'Shop Name';
    const staffName = session.user?.name || 'Unknown Staff';
    const shopAddress = session.shop?.address || '';
    const difference = closingCash - expectedCash;

    // Header Section
    doc.setFontSize(22);
    doc.text(shopName, 14, 20);

    doc.setFontSize(10);
    if (shopAddress) {
      doc.text(shopAddress, 14, 26);
    }

    doc.line(14, 30, 196, 30); // Horizontal line

    // Metadata Section
    doc.setFontSize(12);
    doc.text("End of Shift Report", 14, 40);

    doc.setFontSize(10);
    const metadata = [
      [`Report ID:`, session.id.slice(0, 8).toUpperCase()],
      [`Generated By:`, staffName],
      [`Date Generated:`, format(new Date(), 'PPpp')],
      [`Shift Opened:`, format(new Date(session.opened_at), 'PPpp')],
      [`Shift Closed:`, session.closed_at ? format(new Date(session.closed_at), 'PPpp') : 'Active'],
    ];

    let metaY = 48;
    metadata.forEach(([label, value]) => {
      doc.font = "helvetica", "bold";
      doc.text(label as string, 14, metaY);
      doc.font = "helvetica", "normal";
      doc.text(value as string, 50, metaY);
      metaY += 6;
    });

    // Financial Summary Table
    autoTable(doc, {
      startY: metaY + 5,
      head: [['Financial Summary', 'Amount']],
      body: [
        ['Opening Cash', `${session.opening_cash.toLocaleString()} RWF`],
        ['Total Sales', `${session.total_sales.toLocaleString()} RWF`],
        ['Expected Cash', `${expectedCash.toLocaleString()} RWF`],
        ['Actual Cash Count', `${closingCash.toLocaleString()} RWF`],
        ['Variance', `${difference > 0 ? '+' : ''}${difference.toLocaleString()} RWF`],
      ],
      theme: 'grid',
      headStyles: { fillColor: [66, 66, 66] },
    });

    // Detailed Orders Table
    if (shiftOrders && shiftOrders.length > 0) {
      const finalY = (doc as any).lastAutoTable.finalY || 100;
      doc.setFontSize(12);
      doc.text("Detailed Order History", 14, finalY + 15);

      const tableBody = shiftOrders.map(order => [
        order.order_code,
        format(new Date(order.created_at), 'HH:mm:ss'),
        order.payment_method?.replace('_', ' ').toUpperCase(),
        `${order.total_amount.toLocaleString()} RWF`,
        order.order_items?.map((i: any) => `${i.quantity}x ${i.product?.name}`).join(', ') || ''
      ]);

      autoTable(doc, {
        startY: finalY + 20,
        head: [['Order #', 'Time', 'Payment', 'Total', 'Items']],
        body: tableBody,
        theme: 'striped',
        headStyles: { fillColor: [41, 128, 185] },
        columnStyles: {
          4: { cellWidth: 80 } // Wider column for items
        }
      });
    }

    // Notes Section
    if (description) {
      const finalY = (doc as any).lastAutoTable.finalY || 150;
      doc.setFontSize(12);
      doc.text("Shift Notes", 14, finalY + 15);
      doc.setFontSize(10);
      const splitNotes = doc.splitTextToSize(description, 180);
      doc.text(splitNotes, 14, finalY + 22);
    }

    // Footer
    const pageCount = (doc as any).internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(150);
      doc.text(`BakeSync POS Report - ${shopName} - Staff: ${staffName} - Page ${i} of ${pageCount}`, 14, doc.internal.pageSize.height - 10);
    }

    doc.save(`Shift_Report_${session.shop?.name.replace(/\s+/g, '_')}_${format(new Date(), 'yyyyMMdd')}.pdf`);
    toast.success("PDF exported successfully");
    return true;
  } catch (error) {
    console.error("PDF Gen Error:", error);
    toast.error("Failed to generate PDF");
    return false;
  }
};
